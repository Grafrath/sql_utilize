use academy_db;

-- 학생 테이블
CREATE TABLE student (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);

INSERT INTO student (id, name) VALUES
(1, '철수'),
(2, '영희'),
(3, '민수');

-- 수강 테이블
CREATE TABLE enroll (
  id INT PRIMARY KEY,
  student_id INT,
  class_name VARCHAR(50),
  constraint STD_FK foreign key  (student_id) REFERENCES student(id)
);

INSERT INTO enroll (id, student_id, class_name) VALUES
(1, 1, '데이터베이스'),
(2, 1, '자바'),
(3, 2, '데이터베이스');

SELECT * FROM student;

SELECT * FROM enroll;

SELECT s.name, e.class_name from student s
inner join enroll e on e.student_id = s.id;

alter table product RENAME product_old;

-- 상품 테이블
CREATE TABLE product (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  price INT
);

INSERT INTO product VALUES
(1, '노트북', 1200000),
(2, '스마트폰', 800000),
(3, '키보드', 50000),
(4, '마우스', 30000),
(5, '모니터', 200000);

-- 주문 테이블
CREATE TABLE order_list (
  order_id INT PRIMARY KEY,
  product_id INT,
  quantity INT,
  order_date DATE,
  FOREIGN KEY (product_id) REFERENCES product(id)
);

INSERT INTO order_list VALUES
(101, 1, 1, '2025-01-01'),
(102, 3, 2, '2025-01-02'),
(103, 2, 1, '2025-01-02'),
(104, 5, 3, '2025-01-03'),
(105, 1, 1, '2025-01-04');

-- 상품이름과 주문수량 조회
SELECT p.name, SUM(l.quantity) AS total_quantity FROM product p
JOIN order_list l ON p.id = l.product_id GROUP BY p.name;

-- 주문된 모든 상품의 상품명, 가격, 주문날짜 조회
SELECT l.order_id, p.name, p.price, l.order_date FROM product p
JOIN order_list l ON p.id = l.product_id ORDER BY l.order_id;

-- 상품이름이 노트북인 주문의 주문id, 수량, 날짜 조회
SELECT l.order_id, l.quantity, l.order_date FROM order_list l
JOIN product p ON p.id = l.product_id WHERE p.name = '노트북';

-- 2025-1-2에 주문된 상품들의 상품 이름과 수량 조회
SELECT p.name, l.quantity FROM order_list l
JOIN product p ON p.id = l.product_id WHERE l.order_date = '2025-01-02';

-- 상품명, 수량, 가격, 주문금액(가격*수량)을 함께 출력
SELECT p.name, SUM(l.quantity) AS total_quantity, p.price, p.price * SUM(l.quantity) AS order_price
FROM product p JOIN order_list l ON p.id = l.product_id GROUP BY p.name, p.price;

-- 2번이상 주문된적 있는 상품의 상품명과 총 주문횟수 조회
SELECT p.name, COUNT(l.order_id) AS order_count FROM product p
JOIN order_list l ON p.id = l.product_id
GROUP BY p.name HAVING COUNT(l.order_id) >= 2;

-- LEFT OUTER JOIN(왼쪽 기준, 왼쪽의 데이터는 다 나오게)
-- 왼쪽 테이블은 조건과 상관없이 다 보여주고, 오른쪽 테이블은 매칭되는 것만 붙이는 JOIN**이다

SELECT s.name, e.class_name FROM student AS s
LEFT JOIN enroll AS e ON s.id = e.student_id;
-- 매칭되는 데이터가 없으면 NULL로 채운다

-- 상품명과 주문id를 출력하되 주문이 없는 상품도 조회
SELECT p.name, l.order_id FROM product p
LEFT JOIN order_list l ON p.id = l.product_id
ORDER BY p.id;

-- 주문이 한번도 없는 상품의 모든 내용 조회
SELECT p.* FROM product p
LEFT JOIN order_list l ON p.id = l.product_id
WHERE l.order_id IS NULL;

-- 상품명, 총 주문수량 조회
SELECT p.name, COALESCE(SUM(l.quantity), 0) AS total_quantity FROM product p
LEFT JOIN order_list l ON p.id = l.product_id
GROUP BY p.name;

-- RIGHT OUTER JOIN 왼쪽이 아니라 **오른쪽 테이블을 기준으로 전부 출력**하는 JOIN이다
SELECT s.name, e.class_name FROM student AS s
RIGHT JOIN enroll AS e ON s.id = e.student_id;

-- CROSS JOIN(곱집합, 데카르트 곱) 조건 없이 모든 조합을 다 만들어 버리는 JOIN이다

CREATE TABLE color (
  name VARCHAR(20)
);

INSERT INTO color VALUES ('빨강'), ('파랑');

CREATE TABLE size (
  name VARCHAR(20)
);

INSERT INTO size VALUES ('S'), ('M'), ('L');

-- 색과 사이즈의 모든조합
-- on을 따로 안써도 된다, 모든행을 무조건 서로 짝짓는다.
SELECT c.name, s.name FROM color c
CROSS JOIN size s;

CREATE TABLE days (
  id int primary key,
  day_of_week varchar(10)
);

INSERT INTO days values
	(1,'월'),
	(2,'화'),
	(3,'수'),
	(4,'목'),
	(5,'금'),
	(6,'토'),
	(7,'일');

CREATE TABLE Time_slots (
  id int primary key,
  time TIME
);

INSERT INTO Time_slots values
	(1,'09:00'),
	(2,'10:00'),
	(3,'11:00'),
	(4,'12:00'),
	(5,'13:00'),
	(6,'14:00'),
	(7,'15:00');

SELECT * FROM days;
SELECT * FROM Time_slots;

SELECT d.day_of_week, t.time FROM days d
CROSS JOIN Time_slots t
WHERE day_of_week IN ('월', '수', '금');

-- SELF JOIN 하나의 테이블을 두 번 불러서 서로 JOIN하는 것이다.

CREATE TABLE employee (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  manager_id INT  -- 상사의 id
);

INSERT INTO employee VALUES
(1, '대표', NULL),
(2, '팀장', 1),
(3, '사원A', 2),
(4, '사원B', 2);

-- 사원이 누구를 상사로 두고 있는지 조회하기
SELECT e.name, m.name FROM employee e
LEFT JOIN employee m ON e.manager_id = m.id;

-- ON VS WHERE JOIN은 반드시 `ON` 으로 관계를 연결해야 한다.
SELECT s.name, e.class_name FROM student s
LEFT JOIN enroll e ON s.id = e.student_id
WHERE e.class_name = '데이터베이스';
-- 수업이 ‘데이터베이스’인 수강 이력이 있는 학생만

-- `ON`은 두 테이블을 어떻게 엮을지를 정의한다
-- `WHERE`는 **JOIN이 끝난 결과에서 필터링을 하는 역할을 한다
SELECT s.name, e.class_name FROM student s
LEFT JOIN enroll e ON s.id = e.student_id AND e.class_name = '데이터베이스';
-- 모든 학생을 다 보여주되, 수업명은 ‘데이터베이스’가 아니면 NULL

use employees

-- employees와 salaries 테이블을 JOIN하여 직원의 이름(first_name)과 급여(salary)를 조회하시오.
SELECT e.emp_no, e.first_name, s.salary FROM employees e
JOIN salaries s ON e.emp_no = s.emp_no
WHERE s.to_date = '9999-01-01';

-- employees와 titles 테이블을 JOIN하여 직원의 이름(first_name), 직책(title)을 조회하시오.
SELECT e.emp_no, e.first_name, t.title FROM employees e
JOIN titles t ON e.emp_no = t.emp_no
WHERE t.to_date = '9999-01-01';

-- - 회사 인사팀에서 **현재 어떤 부서에 속해 있는 직원 목록**이 필요하다.
-- 현재 부서 기준: `dept_emp.to_date = '9999-01-01'`
-- 직원 이름(first_name, last_name) + 부서 이름(dept_name)을 JOIN해서 한 줄로 조회하라
SELECT e.emp_no, e.first_name, e.last_name, d.dept_no, d.dept_name FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON d.dept_no = de.dept_no
WHERE de.to_date = '9999-01-01' ORDER by e.emp_no;
    
-- employees 테이블을 SELF J OIN하여 직원 이름과 그 직원의 상사 이름을 조회하시오.
-- ? 상사가 누군지 알수 있는 정보가 없는데?

-- employees와 dept_emp를 JOIN하여 직원의 이름(first_name)과 부서 배정 날짜(from_date)를 조회하시오.
SELECT e.emp_no, e.first_name, de.from_date, d.dept_name FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON d.dept_no = de.dept_no
WHERE de.to_date = '9999-01-01' ORDER by e.emp_no;

-- dept_emp와 departments 테이블을 JOIN하여 부서 번호(dept_no)와 부서 이름(dept_name)을 모두 조회하시오.

-- titles와 employees 테이블을 JOIN하여 직책이 'Engineer'인 직원들의 이름을 조회하시오.




-- VIEW SELECT문을 저장해 둔 가상의 테이블이다.
-- 뷰는 실제 데이터를 저장하지 않고 실제 테이블을 조회한 결과를 보여주는 창(Window) 역할을 한다.

-- 실제 데이터가 저장되지 않는다, 뷰는 SELECT문의 결과를 보여줄 뿐 테이블처럼 데이터를 저장하지 않는다.
-- 복잡한 쿼리를 단순하게 만들 수 있다, JOIN, 조건이 많은 SELECT문을 뷰로 만들어두면 유지보수가 편하다.
-- 보안(열 제한) 원본 테이블의 민감한 정보(예: salary)를 숨기고 필요한 정보만 보여줄 수 있다.
-- 테이블처럼 SELECT로 조회 가능하다


-- 사원과 현재 소속 부서를 JOIN한 뷰
SELECT e.emp_no, e.first_name, e.last_name, d.dept_no, d.dept_name FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON d.dept_no = de.dept_no
WHERE de.to_date = '9999-01-01' ORDER by e.emp_no;

CREATE VIEW v_employee_department as
SELECT e.emp_no, e.first_name, e.last_name, d.dept_no, d.dept_name FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON d.dept_no = de.dept_no
WHERE de.to_date = '9999-01-01' ORDER by e.emp_no;

SELECT * FROM v_employee_department;

-- 급여는 숨기고 사원 정보만 제공하는 보안용 뷰
CREATE VIEW v_employee_public AS
SELECT e.emp_no, e.first_name, e.last_name, d.dept_name FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON de.dept_no = d.dept_no
WHERE de.to_date = '9999-01-01' ORDER by e.emp_no;

SELECT * FROM v_employee_public;