CREATE TABLE sales (
  id INT PRIMARY KEY,
  product VARCHAR(50),
  price DECIMAL(10,2),
  quantity INT,
  discount_rate DECIMAL(5,2)  -- 할인율(예: 0.15 → 15%)
);

INSERT INTO sales VALUES
(1, 'Keyboard', 29900, 2, 0.10),
(2, 'Mouse',    15900, 3, 0.05),
(3, 'Monitor',  199000, 1, 0.20),
(4, 'USB',       8900, 10, 0.00),
(5, 'Speaker',  45500, 4, 0.15);

SELECT price % 3 FROM sales;

SELECT TRUNCATE(discount_rate * 100, 0) FROM sales;

SELECT FLOOR(price * quantity) FROM sales;

SELECT FLOOR(ABS(quantity / 3)) FROM sales;

SELECT ROUND(price,-3) FROM sales;

SELECT POWER(price, 2) FROM sales;

SELECT FLOOR(RAND() * 100) + 1;

SELECT NOW(), CURRENT_TIMESTAMP; -- now() 와 동일

SELECT CURTIME(), CURRENT_TIME; -- CURTIME()와 동일

SELECT CURDATE(), CURRENT_DATE;	-- CURDATE()와 동일

-- INTERVAL 뒤에오는 시간단위를 기준으로 계산 INTERVAL expr 더하거나 빼고싶은 숫자값 unit 기간 단위
SELECT
  CURDATE(),
  DATE_ADD(CURDATE(), INTERVAL 7 DAY),      -- 7일 뒤
  DATE_SUB(CURDATE(), INTERVAL 7 DAY), 		-- 7일 전
  DATE_ADD(CURDATE(), INTERVAL 1 week),		-- 1주 뒤
  DATE_ADD(CURDATE(), INTERVAL 2 MONTH),    -- 2달 뒤
  DATE_ADD(CURDATE(), INTERVAL 1 YEAR);     -- 1년 뒤

SELECT DATEDIFF('2025-12-31', '2025-11-14') AS diff_days;  -- 47 같은 값

SELECT
	DATE_FORMAT(now(), '%Y-%m-%d'),
	DATE_FORMAT(now(), '%Y-%m-%d %H:%i:%s'),
	DATE_FORMAT(NOW(), '%Y년 %m월 %d일')    AS korean;

-- `%Y` : 4자리 연도 (2025)
-- `%y` : 2자리 연도 (25)
-- `%m` : 2자리 월 (01~12)
-- `%d` : 2자리 일 (01~31)
-- `%H` : 24시간제 시 (00~23)
-- `%i` : 분 (00~59)
-- `%s` : 초 (00~59)
-- `%W` : 요일 이름 (Sunday~Saturday)

SELECT
	STR_TO_DATE('2025-11-14', '%Y-%m-%d'),
	STR_TO_DATE('14/11/2025 13:30', '%d/%m/%Y %H:%i');

SELECT MAKEDATE(2025, 32);   -- 2025-02-01 (32번째 날)

SELECT DATE_SUB(STR_TO_DATE('2025-12-25', '%Y-%m-%d'), INTERVAL 100 DAY) -- 100일 전

SELECT MAKETIME(13, 30, 0); -- '13:30:00'

-- 연 / 월 / 일 뽑기
SELECT
	NOW() AS now_time,
	YEAR(NOW()) AS y,
	MONTH(NOW()) AS m,
	DAY(NOW()) AS d;

-- 시 / 분 / 초 추출하기
SELECT
	HOUR(NOW())   AS h,
	MINUTE(NOW()) AS mi,
	SECOND(NOW()) AS s;

-- DAYOFWEEK(date) 1(일) ~ 7(토)
-- WEEKDAY(date) 0(월) ~ 6(일)
-- DAYNAME(date) 요일 이름 문자열(Sunday, Monday …)

SELECT
	DAYOFWEEK(CURDATE()) AS dow,
	WEEKDAY(CURDATE()) AS weekday,
	DAYNAME(CURDATE()) AS dayname;

-- LAST_DAY(date) 월의 마지막날 구하기
SELECT
	CURDATE() AS today,
	LAST_DAY(CURDATE()) AS end_of_month;

CREATE TABLE orders_fc (
	id INT PRIMARY KEY AUTO_INCREMENT,
	customer VARCHAR(50),
	order_date DATE,
	ship_date DATE,
	price INT
);

INSERT INTO orders_fc (customer, order_date, ship_date, price) values
('홍길동', '2025-01-02', '2025-01-05', 30000),
('이몽룡', '2025-01-10', '2025-01-12', 45000),
('성춘향', '2024-12-28', '2025-01-03', 52000),
('김철수', '2025-02-01', '2025-02-03', 15000),
('박영희', '2025-02-10', NULL, 22000);  -- 아직 배송되지 않음

### 주문 날짜에서 연/월/일 추출하기 `order_date` 컬럼에서 연(year),월(month),일(day)을 추출해서 조회하시오.
SELECT customer, YEAR(order_date) AS y, MONTH(order_date) AS m, DAY(order_date) AS d FROM orders_fc;

### 배송까지 걸린 일수 계산하기 `order_date` 와 `ship_date` 의 차이를 이용해 배송까지 걸린 일수를 `delivery_days` 라는 이름으로 조회하시오.
SELECT customer, order_date, ship_date, DATEDIFF(ship_date, order_date)
AS delivery_days FROM orders_fc WHERE ship_date IS NOT NULL;

### 특정 달의 주문만 조회하기 `2025년 1월` 에 주문된 주문만 조회하시오.
SELECT customer, order_date FROM orders_fc WHERE DATE_FORMAT(order_date, '%m월') = '01월';

### 다음달 배송 예정일 계산하기 모든 주문의 `order_date` 를 기준으로 7일 후 배송 예정일(expected_ship_date)을 계산하여 조회하시오.
SELECT customer, order_date, DATE_ADD(order_date, INTERVAL 7 DAY) AS expected_ship_date FROM orders_fc;

### 작년 주문만 조회하기 `order_date` 를 기준으로 작년에 주문된 기록만 조회하시오
SELECT * FROM orders_fc WHERE YEAR(order_date) = YEAR(CURDATE()) - 1;

### 요일 확인하기 각 `order_date` 가 어떤 요일인지 요일 이름으로 조회하세요
SELECT  customer, order_date, DAYNAME(order_date) AS dayname FROM orders_fc;

CREATE TABLE score (
  id INT,
  name VARCHAR(30),
  subject VARCHAR(20),
  point INT
);

INSERT INTO score VALUES
(1, '홍길동', '국어', 85),
(2, '김철수', '영어', 90),
(3, '이영희', '수학', 78),
(4, '박민수', '영어', 92),
(5, '최다혜', '국어', NULL);

-- COUNT() 값의 개수를 반환하는 함수다.
SELECT COUNT(*) FROM score;	-- 전체 행 수(5)
SELECT COUNT(point) FROM score;	-- 점수가 NULL이 아닌 개수(4)
SELECT COUNT(name) FROM score;	-- NULL 없는 컬럼(5)

-- SUM() NULL은 제외한 총합을 구한다.
SELECT SUM(point) FROM score;	-- 85+90+78+92 = 345

-- AVG() NULL을 제외하고 평균을 계산한다.
SELECT AVG(point) FROM score;	-- (85+90+78+92)/4

-- MAX() 최대값을 구한다.
SELECT MAX(point) FROM score;	-- 92

-- MIN() 최소값을 구한다.
SELECT MIN(point) FROM score;	-- 78

-- 일반적으로 집계함수는 SELECT절에 다른 컬럼들과 함께 사용할 수 없다.
-- SELECT id, nameSUM(point) FROM score;

CREATE TABLE employee_salary (
  id INT AUTO_INCREMENT PRIMARY KEY,	-- 사번
  name VARCHAR(50),		-- 이름
  department VARCHAR(50),	-- 부서
  salary INT,	-- 급여
  bonus_rate DECIMAL(4,2),   -- 보너스율(0.1 = 10%)
  hire_date DATE -- 입사일
);

INSERT INTO employee_salary (name, department, salary, bonus_rate, hire_date) VALUES
('홍길동', '개발팀', 4200000, 0.10, '2020-02-01'),
('김유신', '개발팀', 3800000, 0.15, '2021-03-15'),
('강감찬', '영업팀', 3500000, 0.08, '2019-07-10'),
('이순신', '영업팀', 5000000, 0.20, '2018-11-20'),
('유관순', '인사팀', 3000000, 0.05, '2022-01-05'),
('장보고', '인사팀', 3100000, 0.07, '2023-03-10'),
('신사임당', '개발팀', 4500000, 0.12, '2017-06-25'),
('정약용', '영업팀', 3900000, 0.15, '2020-09-01');


SELECT COUNT(*) FROM employee_salary;

SELECT AVG(salary) FROM employee_salary;

SELECT SUM(salary) FROM employee_salary WHERE department = '개발팀';

SELECT COUNT(*) FROM employee_salary WHERE YEAR(hire_date) <= YEAR(CURDATE()) - 5 ;		-- 연도만 비교 (1년가량 오차 가능)
SELECT COUNT(*) FROM employee_salary WHERE hire_date <= DATE_SUB(CURDATE(), INTERVAL 5 YEAR) ;		-- 정확한 5년 이전 날짜 기준

-- GROUP BY
-- 데이터를 특정 기준으로 묶어서 요약하는 문법
-- 보통 **집계 함수(AVG, COUNT, SUM, MIN, MAX)** 와 함께 사용한다.

CREATE TABLE sales_prod (
    id INT AUTO_INCREMENT PRIMARY KEY,
    category VARCHAR(20),
    amount INT,
    sale_date DATE
);

INSERT INTO sales_prod   (category, amount, sale_date) VALUES
('전자제품', 300000, '2025-01-01'),
('전자제품', 250000, '2025-01-03'),
('생활용품', 15000, '2025-01-02'),
('생활용품', 20000, '2025-01-05'),
('식품', 5000, '2025-01-03');

-- 카테고리별 매출 합계
SELECT category, SUM(amount) AS total_amount
FROM sales_prod
GROUP BY category;

-- 카테고리별 판매 건수
SELECT category, COUNT(*) AS cnt
FROM sales_prod
GROUP BY category;

-- 월별 매출 합계
SELECT MONTH(sale_date) AS month, SUM(amount) AS total_amount
FROM sales_prod
GROUP BY MONTH(sale_date);

-- 카테고리별 그리고 월별 세부 집계
SELECT 
    category,
    MONTH(sale_date) AS month,
    SUM(amount) AS total_amount
FROM sales_prod
GROUP BY category, MONTH(sale_date);

-- employee_salary 테이블에서 부서별 평균 급여와 최고 급여를 조회
SELECT department, TRUNCATE(AVG(salary), 0) AS salary_avg, MAX(salary) AS salary_high
FROM employee_salary
GROUP BY department;

-- 입사 연도별 직원 수
SELECT YEAR(hire_date), COUNT(*)
FROM employee_salary
GROUP BY YEAR(hire_date);

-- 급여 첫 숫자별 직원수
SELECT LEFT(CONVERT(salary, CHAR),1), COUNT(*)
FROM employee_salary
GROUP BY LEFT(CONVERT(salary, CHAR),1);


-- 가장 최근 입사자
SELECT name, hire_date FROM employee_salary
GROUP BY name, hire_date HAVING hire_date = MAX(hire_date);

-- Having 그룹화된 결과에 조건을 적용할 때 사용하는 구문이다.
-- WHERE와 매우 비슷해 보이지만, 적용되는 시점과 대상이 다르다는 점이 핵심이다.
-- 집계 함수(SUM, AVG, COUNT 등)를 조건으로 사용할 때 주로 사용한다.
-- WHERE과 HAVING의 차이
-- 구분 WHERE와 HAVING
-- 필터링 시점 그룹화 이전 그룹화 이후
-- 사용 대상 개별 행(row) 그룹(group)
-- 집계 함수 조건 ❌ 불가능 ✔ 가능
-- 주 사용목적 데이터 전처리 그룹 조건 필터

-- WHERE는 행을 필터링하고, HAVING은 그룹을 필터링한다.

-- 총 판매금액이 50,000원 이상인 카테고리를 조회하기
SELECT category, SUM(amount) AS total_amount
FROM sales_prod
GROUP BY category
HAVING SUM(amount) >= 50000;

# 똑같은 걸 WHERE에 쓰면 어떻게 될까?
#SELECT category, SUM(amount) AS total_amount
#FROM sales_prod
#WHERE SUM(amount) >= 50000   -- ❌ 잘못된 코드
#GROUP BY category;

# WHERE은 행(row) 단위에서 필터링하는 단계라서 아직 SUM(amount)가 계산되기 전이라 사용할 수 없다.

-- 판매가 2번 이상 발생한 카테고리만 조회하기
SELECT category, COUNT(*) AS sale_count
FROM sales_prod
GROUP BY category
HAVING COUNT(*) >= 2;

-- 카테고리별 평균 결제 금액이 100,000원 이상인 것만 조회하기
SELECT category, AVG(amount) AS avg_amount
FROM sales_prod
GROUP BY category
HAVING AVG(amount) >= 100000;

-- 2025-01-02 이후의 거래만 대상으로, 카테고리별 총액이 20,000 이상인 경우만 조회하기
SELECT category, SUM(amount) AS total_amount
FROM sales_prod
WHERE sale_date >= '2025-01-03'
GROUP BY category
HAVING SUM(amount) >= 20000;

-- 카테고리별 총 판매금액(SUM(amount))을 구하시오.
-- 단, 총 판매금액이 200,000원 이상인 카테고리만 조회**하시오.
SELECT category, SUM(amount) AS avg_amount
FROM sales_prod
GROUP BY category
HAVING SUM(amount) >= 200000;

-- 카테고리별 판매 건수를 구하시오.
-- 단, 판매 건수가 2건 이상인 카테고리만 조회**하시오.
SELECT category, COUNT(*) AS sale_count
FROM sales_prod
GROUP BY category
HAVING COUNT(*) >= 2;

-- employee_salary 테이블에서 인원이 2명이상인 부서 조회
SELECT department, COUNT(*) AS department_count
FROM employee_salary
GROUP BY department
HAVING COUNT(*) >= 2;

-- 2020년 이후 입사한 직원들 대상, 부서별 평균 급여 4백 이상인 부서만 부서명 평균급여 조회
SELECT department, TRUNCATE(AVG(salary), 0) AS salary_avg
FROM employee_salary
WHERE YEAR(hire_date) >= '2020'
GROUP BY department
HAVING TRUNCATE(AVG(salary), 0) >= 4000000;

-- SubQuery 메인쿼리(Main Query) 안에 포함되는 부속 SELECT문이다.
-- 괄호 ( ) 안에서 실행되며, 먼저 실행된 뒤 그 결과를 메인쿼리가 사용한다.
-- 서브쿼리가 사용되는 경우: 특정 조건을 찾기 어려울 때, 집계 결과를 다시 조건으로 사용하고 싶을 때, 존재 여부를 판단할 때

-- 전체 평균 금액보다 큰 금액 조회
SELECT * FROM sales_prod
WHERE amount > (SELECT AVG(amount) FROM sales_prod);

use employees;


-- 가장 최근 입사자 정보 조회
SELECT * FROM employees
WHERE hire_date = (
    SELECT MAX(hire_date)
    FROM employees
);

-- 평균보다 많이 받는 사원 정보 조회 salaries
SELECT e.*, s.salary FROM employees e
JOIN salaries s ON e.emp_no = s.emp_no
WHERE s.salary > (SELECT AVG(salary) FROM salaries
);
